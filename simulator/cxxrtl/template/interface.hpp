#ifndef interface_hpp
#define interface_hpp

#include <backends/cxxrtl/cxxrtl.h>

#include <cmath>
#include <cstddef>
#include <vector>

// Define Macro
#define CONCATENATE(in0, in1, in2) in0##in1##in2
#define SET_VALUE_FUNC(bitwidth, type)                              \
    void CONCATENATE(set, bitwidth, BitsVal)(const unsigned& val) { \
        item->set<bitwidth, type>(val);                             \
    };

#define SET_WIDTH_CONDITION(signal_width) \
    else if (width == signal_width)   \
        CONCATENATE(set, signal_width, BitsVal)(value);

#define SET_CXX_SIGNAL(signal_type, signal_name) \
    signal_type.emplace_back(SignalInfo(const_cast<cxxrtl::debug_item*>(&items->at(signal_name)), signal_name));

struct SignalInfo {
public:
    SignalInfo(const cxxrtl::debug_item* it, std::string n) : item(it), name(n) {
    }
    void setBoolVal(const bool& val) {
        item->set<1, bool>(val);
    }
    // Set signal value functions

    // End (Code is generated by GV)

    unsigned getUpper() { return std::pow(2, item->width); }
    unsigned getValue() { return *(item->curr); }
    unsigned getWidth() { return item->width; }

    void setValue(size_t value) {
        size_t width = item->width;
        if (width == 1) setBoolVal(value);
        // Set N bits value condition

        // End (Code is generated by GV)
    }

    const cxxrtl::debug_item* item;
    std::string name;
};

class Interface {
public:
    Interface(cxxrtl::debug_items* items) {
        // CLK Init

        // RST Init

        // PI Init List

        // PO Init List

        // REG Init List

        // MEM Init List
    }

    std::vector<SignalInfo> clk;
    std::vector<SignalInfo> rst;
    std::vector<SignalInfo> po;
    std::vector<SignalInfo> pi;
    std::vector<SignalInfo> reg;
    std::vector<SignalInfo> mem;
};

#endif /* interface_hpp */
